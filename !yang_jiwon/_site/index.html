<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.523">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="양지원">
<meta name="dcterms.date" content="2024-02-10">

<title>yang_jiwon - 농약 잔류물 처리 기술 연구</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">yang_jiwon</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="./index.html" aria-current="page"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#조은혜-교수님-sci-논문-리스트" id="toc-조은혜-교수님-sci-논문-리스트" class="nav-link active" data-scroll-target="#조은혜-교수님-sci-논문-리스트">조은혜 교수님 SCI 논문 리스트</a></li>
  <li><a href="#실험-내용-및-데이터" id="toc-실험-내용-및-데이터" class="nav-link" data-scroll-target="#실험-내용-및-데이터">실험 내용 및 데이터</a></li>
  <li><a href="#표-및-그래프-분석" id="toc-표-및-그래프-분석" class="nav-link" data-scroll-target="#표-및-그래프-분석">표 및 그래프 분석</a></li>
  <li><a href="#논의-내용" id="toc-논의-내용" class="nav-link" data-scroll-target="#논의-내용">논의 내용</a></li>
  <li><a href="#농업토양정량분석-관련-자료" id="toc-농업토양정량분석-관련-자료" class="nav-link" data-scroll-target="#농업토양정량분석-관련-자료">농업/토양/정량분석 관련 자료</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">농약 잔류물 처리 기술 연구</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>양지원 </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 10, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>제목: 농업 환경에서 미세 플라스틱 및 농약 잔류물의 흡착 거동 및 독성 효과 조사</p>
<p>초록 : 이 논문에서는 농업 환경에서 미세플라스틱과 농약 잔류물의 흡착 거동과 독성 영향을 탐구합니다. 이 연구에서는 이러한 오염 물질의 영향을 완화하기 위해 다양한 처리 기술을 조사하여 지속 가능한 농업 관행과 환경 보존에 대한 통찰력을 제공합니다.</p>
<ol type="1">
<li><p>소개: 전통적인 농화학 연구와 달리, 이 연구는 농업 환경에서 미세플라스틱과 농약 잔류물의 역학에 중점을 둡니다. 이러한 오염 물질을 줄이고 제거하기 위한 운명, 독성 및 처리 기술을 이해하는 데 중점을 둡니다. 이 연구는 농업 관행이 환경에 미치는 영향을 포괄적으로 이해하는 데 도움이 됩니다.</p></li>
<li><p>방법: 연구 방법론에는 미세 플라스틱, 농약 잔류물 및 농업 환경에서의 흡착 거동에 관한 기존 문헌에 대한 광범위한 검토가 포함됩니다. 실험실 실험에서는 분광학 및 크로마토그래피를 포함한 고급 분석 기술을 사용하여 오염 물질 수준을 정량화합니다. 흡착 연구는 처리 기술의 효율성을 평가하여 잠재적 응용 분야에 대한 귀중한 데이터를 제공하기 위해 수행됩니다.</p></li>
<li><p>실험 및 결과: 실험 단계에는 미세플라스틱과 농약 잔류물의 존재에 초점을 맞춰 다양한 농업 현장에서 토양과 물 샘플을 수집하는 것이 포함됩니다. 엄격한 분석을 통해 이러한 오염물질의 흡착 거동과 독성 효과를 평가합니다. 그 효과를 확인하기 위해 흡착 공정, 여과 방법 등 다양한 처리 기술이 적용됩니다. 결과는 각 기술의 성공과 한계를 밝히고 농업 환경에서의 실제 적용을 안내합니다.</p></li>
<li><p>논의: 토론 섹션에서는 실험 결과를 해석하여 농업 관행과 환경 지속 가능성에 대한 의미를 다룹니다. 가공 기술에 대한 비교 분석이 제시되어 미세플라스틱 및 농약 잔류물을 흡착하는 효능을 강조합니다. 독성 효과를 완화하는 데 있어 흡착 거동의 역할을 탐구하여 오염 물질과 환경 사이의 복잡한 상호 작용에 대한 통찰력을 제공합니다. 이 섹션은 향후 연구 방향과 보다 효율적인 처리 기술 개발을 위한 기반이 됩니다.</p></li>
<li><p>결론: 결론적으로, 이 연구는 농업 환경에서 미세플라스틱과 농약 잔류물이 미치는 영향을 이해하고 완화하는 것이 중요하다는 점을 강조합니다. 이번 연구 결과는 지속 가능한 관행을 채택하려는 정책 입안자, 연구자 및 농업 실무자에게 귀중한 통찰력을 제공합니다. 향후 연구에서는 이러한 오염물질의 구체적인 흡착 메커니즘과 장기적인 영향을 더 깊이 조사하여 농업 환경 관리 분야의 지식을 발전시켜야 합니다.</p></li>
</ol>
<hr>
<p>Title: Investigating Adsorption Behavior and Toxic Effects of Microplastics and Pesticide Residues in Agricultural Environments</p>
<p>Abstract: This paper explores the adsorption behavior and toxic effects of microplastics and pesticide residues in the agricultural environment. The study investigates various processing technologies to mitigate the impact of these pollutants, providing insights into sustainable agricultural practices and environmental conservation.</p>
<ol type="1">
<li><p>Introduction: In contrast to traditional agricultural chemistry research, this study focuses on the dynamics of microplastics and pesticide residues in the agricultural environment. Emphasis is placed on understanding the fate, toxicity, and processing technologies aimed at reducing and removing these pollutants. The research contributes to a comprehensive understanding of the environmental implications of agricultural practices.</p></li>
<li><p>Method: The research methodology involves an extensive review of existing literature on microplastics, pesticide residues, and their adsorption behavior in agricultural settings. Laboratory experiments employ advanced analytical techniques, including spectroscopy and chromatography, to quantify pollutant levels. Adsorption studies are conducted to assess the efficiency of processing technologies, providing valuable data on their potential applications.</p></li>
<li><p>Experimentals and Results: The experimental phase includes the collection of soil and water samples from diverse agricultural sites, focusing on the presence of microplastics and pesticide residues. Rigorous analysis evaluates the adsorption behavior of these pollutants and their toxic effects. Various processing technologies, such as adsorption processes and filtration methods, are applied to determine their effectiveness. Results elucidate the success and limitations of each technology, guiding practical applications in agricultural settings.</p></li>
<li><p>Discussion: The discussion section interprets experimental findings, addressing the implications for agricultural practices and environmental sustainability. Comparative analysis of processing technologies is presented, highlighting their efficacy in adsorbing microplastics and pesticide residues. The role of adsorption behavior in mitigating toxic effects is explored, providing insights into the complex interactions between pollutants and the environment. This section serves as a foundation for future research directions and the development of more efficient processing technologies.</p></li>
<li><p>Conclusion: In conclusion, this study underscores the importance of understanding and mitigating the impact of microplastics and pesticide residues in agricultural environments. The findings contribute valuable insights for policymakers, researchers, and agricultural practitioners seeking to adopt sustainable practices. Future research should delve deeper into the specific adsorption mechanisms of these pollutants and their long-term effects, advancing our knowledge in the field of agricultural environmental management.</p></li>
</ol>
<hr>
<p><a href="https://pubmed.ncbi.nlm.nih.gov/?term=Eun+Hea+Jho&amp;sort=pubdate&amp;size=20">지도교수 : 조은혜 교수</a></p>
<section id="조은혜-교수님-sci-논문-리스트" class="level2">
<h2 class="anchored" data-anchor-id="조은혜-교수님-sci-논문-리스트">조은혜 교수님 SCI 논문 리스트</h2>
<p><a href="https://pubmed.ncbi.nlm.nih.gov/?term=Eun+Hea+Jho&amp;sort=pubdate&amp;size=20">리스트 url</a></p>
<p><a href="https://pubmed.ncbi.nlm.nih.gov/33113057/">최신 논문1</a></p>
<p>농업용 농약 제제 연구 : Pesticide Formulations</p>
<p><a href="https://pubmed.ncbi.nlm.nih.gov/31202066/">최신 논문2</a></p>
<p>장기간 비소로 오염된 토양에서 점토에 의한 변화</p>
</section>
<section id="실험-내용-및-데이터" class="level2">
<h2 class="anchored" data-anchor-id="실험-내용-및-데이터">실험 내용 및 데이터</h2>
</section>
<section id="표-및-그래프-분석" class="level2">
<h2 class="anchored" data-anchor-id="표-및-그래프-분석">표 및 그래프 분석</h2>
</section>
<section id="논의-내용" class="level2">
<h2 class="anchored" data-anchor-id="논의-내용">논의 내용</h2>
</section>
<section id="농업토양정량분석-관련-자료" class="level2">
<h2 class="anchored" data-anchor-id="농업토양정량분석-관련-자료">농업/토양/정량분석 관련 자료</h2>
<ul>
<li>AQP</li>
</ul>
<p>AQP(Algorithms for Quantitative Pedology)는 토양학에서 사용되는 알고리즘을 연구하고 개발하는 분야입니다. 이 알고리즘은 토양의 양적인 특성과 속성을 분석하고 모델링하는 데 사용됩니다. AQP는 토양과 관련된 데이터를 분석하여 토양의 특성을 이해하고 더 나은 농업 및 환경 관리 결정을 내리는 데 도움이 됩니다</p>
<p><a href="&quot;https://ncss-tech.github.io/AQP/&quot;">AQP 패키지 모음</a></p>
<p><a href="&quot;https://cran.r-project.org/web/views/Agriculture.html&quot;">Agricultural Science 패키지 모음</a></p>
<p><a href="&quot;https://ncss-tech.github.io/soilDB/&quot;">토양 DB 패키지</a></p>
<p><a href="&quot;https://github.com/paleolimbot/oceandf&quot;">해양 패키지</a></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>