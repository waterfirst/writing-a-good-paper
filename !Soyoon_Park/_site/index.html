<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.523">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="박소윤">
<meta name="dcterms.date" content="2024-02-10">

<title>Soyoon_Park - 농업용 항생제 논문</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Soyoon_Park</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="./index.html" aria-current="page"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#조은혜-교수님-sci-논문-리스트" id="toc-조은혜-교수님-sci-논문-리스트" class="nav-link active" data-scroll-target="#조은혜-교수님-sci-논문-리스트">조은혜 교수님 SCI 논문 리스트</a></li>
  <li><a href="#실험-내용-및-데이터" id="toc-실험-내용-및-데이터" class="nav-link" data-scroll-target="#실험-내용-및-데이터">실험 내용 및 데이터</a></li>
  <li><a href="#표-및-그래프-분석" id="toc-표-및-그래프-분석" class="nav-link" data-scroll-target="#표-및-그래프-분석">표 및 그래프 분석</a></li>
  <li><a href="#논의-내용" id="toc-논의-내용" class="nav-link" data-scroll-target="#논의-내용">논의 내용</a></li>
  <li><a href="#농업토양정량분석-관련-자료" id="toc-농업토양정량분석-관련-자료" class="nav-link" data-scroll-target="#농업토양정량분석-관련-자료">농업/토양/정량분석 관련 자료</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">농업용 항생제 논문</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>박소윤 </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 10, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>제목: 농업 토양에서의 농업용 항생제의 흡착, 탈착 및 분해: 환경 안전에 관한 종합 연구</p>
<p>초록:</p>
<p>이 논문은 다양한 농업 토양에서 농업용 항생제의 흡착, 탈착 및 분해에 대한 철저한 조사를 제시합니다. 이 연구는 이러한 항생제의 환경 안전성을 평가하고 토양 특성이 다양한 매개변수에 미치는 영향을 밝히는 것을 목표로 합니다. 이 연구에는 흡착, 탈착 및 분해의 복잡한 과정에 대한 통찰력을 얻기 위한 실험 수행이 포함되며, 이러한 상호 작용을 지배하는 기본 메커니즘을 이해하는 데 중점을 둡니다. 다양한 토양 유형에서 농업용 항생제의 환경 거동에 대한 포괄적인 이해를 제공하기 위해 결과를 분석합니다.</p>
<p>키워드 : 항생제, 환경안전, 흡착, 탈착, 분해, 농경토양</p>
<p>소개:</p>
<p>농업에서 항생제를 과도하게 사용하면 특히 농업 토양에서 항생제가 환경에 미칠 수 있는 영향에 대한 우려가 높아졌습니다. 본 연구는 다양한 토양 유형에서 농업용 항생제의 흡착, 탈착 및 분해 과정의 복잡한 상호 작용을 조사합니다. 이러한 과정을 이해하는 것은 농업에서 항생제 사용의 환경 안전성을 평가하고 지속 가능한 관행을 개발하는 데 중요합니다.</p>
<p>방법:</p>
<p>다양한 농업 토양에서 선택된 농업용 항생제의 흡착, 탈착 및 분해 거동을 조사하기 위해 일련의 실험실 실험이 수행되었습니다. 실험 설정에는 현실적인 시나리오를 시뮬레이션하고 정확한 데이터 수집을 보장하기 위한 제어된 조건이 포함되었습니다. 항생제의 농도, 토양 특성 및 기타 관련 매개변수는 광범위한 조건을 포착하기 위해 체계적으로 다양해졌습니다.</p>
<p>실험 및 결과:</p>
<p>실험을 통해 다양한 토양 유형에 걸쳐 농업용 항생제의 흡착, 탈착 및 분해 속도에 상당한 차이가 있음이 밝혀졌습니다. 토양 pH, 유기물 함량, 광물 조성과 같은 요인이 이러한 과정에 영향을 미치는 것으로 밝혀졌습니다. 결과는 농업 토양에서 항생제의 환경적 거동에 대한 귀중한 통찰력을 제공하며, 항생제의 영향을 평가할 때 토양 특성을 고려하는 것의 중요성을 강조합니다.</p>
<p>논의:</p>
<p>토론 섹션에서는 기존 문헌 및 이론적 틀의 맥락에서 실험 결과를 해석합니다. 흡착, 탈착 및 분해 과정에 대한 토양 특성의 영향을 분석하고 이러한 상호 작용을 제어하는 잠재적 메커니즘을 논의합니다. 환경 안전과 지속 가능한 농업 관행에 대한 결과의 의미도 탐구됩니다.</p>
<p>결론:</p>
<p>이 연구는 환경 안전성을 평가할 때 토양 특성을 고려할 필요성을 강조하면서 농업 토양에서 농업용 항생제의 거동을 더 잘 이해하는 데 기여합니다. 이 연구에서 얻은 통찰력은 농업에서 항생제 사용이 환경에 미치는 영향을 완화하기 위한 지침 및 전략 개발에 도움이 될 수 있습니다. 향후 연구에서는 특정 토양-항생제 상호작용을 조사하고 이러한 과정에 영향을 미치는 추가 요인을 탐구할 수 있습니다.</p>
<hr>
<p>Title: Adsorption, Desorption, and Decomposition of Agricultural Antibiotics in Agricultural Soils: A Comprehensive Study on Environmental Safety</p>
<p>Abstract:</p>
<p>This paper presents a thorough investigation into the adsorption, desorption, and decomposition of agricultural antibiotics in various agricultural soils. The study aims to evaluate the environmental safety of these antibiotics and elucidate the impact of soil characteristics on different parameters. The research involves conducting experiments to gain insights into the intricate processes of adsorption, desorption, and decomposition, with a focus on understanding the underlying mechanisms governing these interactions. The results are analyzed to provide a comprehensive understanding of the environmental fate of agricultural antibiotics in diverse soil types.</p>
<p>Keywords: antibiotics, environmental safety, adsorption, desorption, decomposition, agricultural soils</p>
<p>Introduction:</p>
<p>The excessive use of antibiotics in agriculture has raised concerns about their potential environmental impact, particularly in agricultural soils. This study investigates the complex interplay of adsorption, desorption, and decomposition processes of agricultural antibiotics in various soil types. Understanding these processes is crucial for assessing the environmental safety of antibiotic use in agriculture and developing sustainable practices.</p>
<p>Method:</p>
<p>A series of laboratory experiments were conducted to examine the adsorption, desorption, and decomposition behaviors of selected agricultural antibiotics in different agricultural soils. The experimental setup included controlled conditions to simulate realistic scenarios and ensure accurate data collection. The antibiotics’ concentrations, soil characteristics, and other relevant parameters were systematically varied to capture a wide range of conditions.</p>
<p>Experimentals and Results:</p>
<p>The experiments revealed significant variations in the adsorption, desorption, and decomposition rates of agricultural antibiotics across different soil types. Factors such as soil pH, organic matter content, and mineral composition were found to influence these processes. The results provide valuable insights into the environmental fate of antibiotics in agricultural soils, highlighting the importance of considering soil characteristics when assessing their impact.</p>
<p>Discussion:</p>
<p>The discussion section interprets the experimental findings in the context of existing literature and theoretical frameworks. The influence of soil properties on adsorption, desorption, and decomposition processes is analyzed, and potential mechanisms governing these interactions are discussed. The implications of the results for environmental safety and sustainable agricultural practices are also explored.</p>
<p>Conclusion:</p>
<p>This study contributes to a better understanding of the fate of agricultural antibiotics in agricultural soils, emphasizing the need to account for soil characteristics when evaluating environmental safety. The insights gained from this research can inform the development of guidelines and strategies for mitigating the environmental impact of antibiotic use in agriculture. Future studies may delve into specific soil-antibiotic interactions and explore additional factors influencing these processes.</p>
<hr>
<p><a href="https://pubmed.ncbi.nlm.nih.gov/?term=Eun+Hea+Jho&amp;sort=pubdate&amp;size=20">지도교수: 조은혜 교수</a></p>
<hr>
<p>농업용 항생제는 작물의 무름병을 방제하기 위한 살균제로 사용됩니다. 농업용 항생제는 일반 합성농약에 비해 높은 선택성과 침투성, 저 독성으로 병해충 방제를 목적으로 사용되어 왔습니다. 농업용 항생제로는 옥솔린산, 발리다마이신, 스트렙토마이신, 가스가마이신, 폴리옥신 등이 있습니다. 이 중 스트렙토마이신은 우수한 약효로 해외에서도 화상병 방제를 위해 가장 많이 사용하는 항생제입니다. 농업용 항생제는 세균 증식과 발병을 저지하는 효과가 있습니다. 침투이행효과가 뛰어나 세균증식을 저해하여 세균 병해 발병을 효과적으로 저지합니다. 농업용 항생제는 신중하게 사용하면 잔류가 되지 않습니다. 하지만 오남용되면서 문제가 발생할 수 있습니다</p>
<hr>
<section id="조은혜-교수님-sci-논문-리스트" class="level2">
<h2 class="anchored" data-anchor-id="조은혜-교수님-sci-논문-리스트">조은혜 교수님 SCI 논문 리스트</h2>
<p><a href="https://pubmed.ncbi.nlm.nih.gov/?term=Eun+Hea+Jho&amp;sort=pubdate&amp;size=20">리스트 url</a></p>
<p><a href="https://pubmed.ncbi.nlm.nih.gov/32758791/">최신 논문1</a></p>
<p>불소화 의약품의 환원적 분해 탐구</p>
<p><a href="https://biz.chosun.com/science-chosun/nature-environment/2023/12/20/L2GLOSW4QJGPPI2FELUUINRLSA/?utm_source=naver&amp;utm_medium=original&amp;utm_campaign=biz">최신 기사2</a></p>
<p>전자레인지 ’마이크로파’로 농사 망치는 병해충 박멸한다</p>
</section>
<section id="실험-내용-및-데이터" class="level2">
<h2 class="anchored" data-anchor-id="실험-내용-및-데이터">실험 내용 및 데이터</h2>
</section>
<section id="표-및-그래프-분석" class="level2">
<h2 class="anchored" data-anchor-id="표-및-그래프-분석">표 및 그래프 분석</h2>
</section>
<section id="논의-내용" class="level2">
<h2 class="anchored" data-anchor-id="논의-내용">논의 내용</h2>
</section>
<section id="농업토양정량분석-관련-자료" class="level2">
<h2 class="anchored" data-anchor-id="농업토양정량분석-관련-자료">농업/토양/정량분석 관련 자료</h2>
<ul>
<li>AQP</li>
</ul>
<p>AQP(Algorithms for Quantitative Pedology)는 토양학에서 사용되는 알고리즘을 연구하고 개발하는 분야입니다. 이 알고리즘은 토양의 양적인 특성과 속성을 분석하고 모델링하는 데 사용됩니다. AQP는 토양과 관련된 데이터를 분석하여 토양의 특성을 이해하고 더 나은 농업 및 환경 관리 결정을 내리는 데 도움이 됩니다</p>
<p><a href="&quot;https://ncss-tech.github.io/AQP/&quot;">AQP 패키지 모음</a></p>
<p><a href="&quot;https://cran.r-project.org/web/views/Agriculture.html&quot;">Agricultural Science 패키지 모음</a></p>
<p><a href="&quot;https://cran.r-project.org/web/packages/vegan/index.html&quot;">농업용 항생제 패키지</a></p>
<p><a href="&quot;https://www.frontiersin.org/articles/10.3389/fvets.2021.633858/full&quot;">vegan 이용한 논문</a> 토양 원핵생물 다양성 데이터 및 16S rRNA 앰플리콘 시퀀싱 데이터 시각화에 대한 α 다양성 지수(즉, 풍부도, Shannon’s, Simpson’s, Pielou’s)를 계산하는 데 사용</p>
<p><a href="&quot;https://ncss-tech.github.io/soilDB/&quot;">토양 DB 패키지</a></p>
<p><a href="&quot;https://github.com/paleolimbot/oceandf&quot;">해양 패키지</a></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>