<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.523">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="김명민">
<meta name="dcterms.date" content="2024-02-10">

<title>Myungmin_Kim - 단백질 정제 및 특성 연구</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Myungmin_Kim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="./index.html" aria-current="page"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#정제훈-교수님-sci-논문-리스트" id="toc-정제훈-교수님-sci-논문-리스트" class="nav-link active" data-scroll-target="#정제훈-교수님-sci-논문-리스트">정제훈 교수님 SCI 논문 리스트</a></li>
  <li><a href="#실험-내용-및-데이터" id="toc-실험-내용-및-데이터" class="nav-link" data-scroll-target="#실험-내용-및-데이터">실험 내용 및 데이터</a></li>
  <li><a href="#표-및-그래프-분석" id="toc-표-및-그래프-분석" class="nav-link" data-scroll-target="#표-및-그래프-분석">표 및 그래프 분석</a></li>
  <li><a href="#논의-내용" id="toc-논의-내용" class="nav-link" data-scroll-target="#논의-내용">논의 내용</a></li>
  <li><a href="#단백질-연구-r-패키지" id="toc-단백질-연구-r-패키지" class="nav-link" data-scroll-target="#단백질-연구-r-패키지">단백질 연구 R 패키지</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">단백질 정제 및 특성 연구</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>김명민 </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 10, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>제목: 단백질 정제 및 특성화 탐구: 클로닝, 정제 기술 및 활동 연구</p>
<p>초록: 이 논문에서는 복제를 통한 재조합 단백질 생성에 특히 중점을 두고 단백질 정제 및 특성화와 관련된 프로세스를 조사합니다. 이 연구에서는 다양한 정제 컬럼을 사용하고 정제된 표적 단백질의 활성 테스트 및 단백질-리간드 결합 특성에 대한 후속 분석을 포함합니다. 이 연구는 재조합 단백질의 행동과 다양한 과학 분야에 걸친 잠재적 응용에 대한 이해를 높이는 것을 목표로 합니다.</p>
<ol type="1">
<li><p>소개: 단백질 구조와 기능을 이해하기 위한 탐구에서 이 연구는 클로닝 기술을 사용하여 재조합 단백질을 생성한 후 여러 컬럼을 사용하여 정제하는 데 중점을 두고 있습니다. 이 연구에서는 단백질 정제 및 특성화와 관련된 단계를 탐구하고 다양한 과학 분야에서 이러한 기술의 실제 적용을 강조합니다.</p></li>
<li><p>방법: 이 방법론에는 표적 단백질을 복제하여 재조합 단백질을 생성하는 과정이 포함됩니다. 후속 정제 공정에서는 다양한 컬럼을 활용하여 크로마토그래피 및 친화성 기술을 사용하여 목적 단백질을 분리 및 정제합니다. 실험 설정은 얻은 결과의 재현성과 신뢰성을 보장합니다.</p></li>
<li><p>실험 및 결과: 실험 절차에는 표적 단백질을 클로닝하고 이를 적합한 숙주 시스템에서 발현시키는 것이 포함됩니다. 정제 과정에는 순차 컬럼 크로마토그래피가 포함되며 각 단계를 주의 깊게 모니터링합니다. 획득된 재조합 단백질은 활성 테스트 및 단백질-리간드 결합 연구를 포함하여 포괄적인 특성 분석을 거칩니다. 결과는 정제 과정의 효율성과 정제된 단백질의 기능적 특성을 강조합니다.</p></li>
<li><p>논의: 토론에서는 실험 결과를 해석하고 고품질 재조합 단백질을 얻는 데 있어 클로닝 및 정제 기술의 중요성을 다룹니다. 다양한 컬럼 크로마토그래피 방법의 비교 분석이 제시되어 해당 방법의 장점과 한계를 강조합니다. 단백질-리간드 결합 특성에 대한 통찰력은 정제된 단백질의 기능적 특성에 대한 이해를 심화시킵니다. 이 섹션은 다양한 과학 분야에서 이러한 기술의 광범위한 적용을 논의하기 위한 플랫폼 역할을 합니다.</p></li>
<li><p>결론: 결론적으로, 이 연구는 단백질 정제 및 특성화에 대한 귀중한 통찰력을 제공합니다. 클로닝 기술과 고급 정제 컬럼을 사용하면 고순도 재조합 단백질을 얻는 데 효과적인 것으로 입증되었습니다. 단백질 활성 및 리간드 결합 특성에 대한 자세한 조사는 기능적 특성에 대한 이해를 향상시킵니다. 이 연구는 해당 분야의 추가 발전을 위한 발판을 마련하고, 이를 추구하는 연구자와 실무자에게 토대를 제공합니다.</p></li>
</ol>
<hr>
<p>Title: Exploring Protein Purification and Characterization: Cloning, Purification Techniques, and Activity Studies</p>
<p>Abstract: This paper investigates the processes involved in protein purification and characterization, with a specific focus on creating recombinant proteins through cloning. The study employs various purification columns and includes subsequent analyses of activity tests and protein-ligand binding characteristics of the purified target protein. This research aims to advance our understanding of recombinant protein behavior and its potential applications across diverse scientific disciplines.</p>
<ol type="1">
<li><p>Introduction: In the quest to comprehend protein structure and function, this research centers on creating recombinant proteins using cloning techniques, followed by their purification with multiple columns. The study explores the steps involved in protein purification and characterization, emphasizing the practical applications of these techniques in various scientific fields.</p></li>
<li><p>Method: The methodology involves cloning target proteins to generate recombinant proteins. The subsequent purification process utilizes diverse columns to isolate and purify the target protein, employing chromatographic and affinity techniques. The experimental setup ensures reproducibility and reliability in the obtained results.</p></li>
<li><p>Experimentals and Results: Experimental procedures include cloning target proteins and expressing them in a suitable host system. The purification process involves sequential column chromatography, with each step carefully monitored. The obtained recombinant protein undergoes comprehensive characterization, including activity tests and studies of protein-ligand binding. Results highlight the efficiency of the purification process and the functional characteristics of the purified protein.</p></li>
<li><p>Discussion: The discussion interprets the experimental findings, addressing the importance of cloning and purification techniques in obtaining high-quality recombinant proteins. Comparative analysis of different column chromatography methods is presented, emphasizing their strengths and limitations. Insights into protein-ligand binding characteristics deepen our understanding of the functional properties of the purified proteins. This section serves as a platform for discussing the broader applications of these techniques in diverse scientific fields.</p></li>
<li><p>Conclusion: In conclusion, this research provides valuable insights into protein purification and characterization. The use of cloning techniques and advanced purification columns has proven effective in obtaining high-purity recombinant proteins. The detailed examination of protein activity and ligand binding characteristics enhances our understanding of their functional properties. This study sets the stage for further advancements in the field, offering a foundation for researchers and practitioners seeking to employ these techniques in their scientific endeavors. - - -</p></li>
</ol>
<p><a href="https://natural.jnu.ac.kr/natural/14500/subview.do?enc=Zm5jdDF8QEB8JTJGcHJvZiUyRm5hdHVyYWwlMkY0MjElMkYxOTElMkZ2aWV3LmRvJTNG">지도교수 : 정제훈 교수</a></p>
<hr>
<section id="정제훈-교수님-sci-논문-리스트" class="level2">
<h2 class="anchored" data-anchor-id="정제훈-교수님-sci-논문-리스트">정제훈 교수님 SCI 논문 리스트</h2>
<p><a href="https://pubmed.ncbi.nlm.nih.gov/?term=Che-Hun+Jung+&amp;sort=pubdate&amp;size=20">리스트 url</a></p>
<p><a href="https://pubmed.ncbi.nlm.nih.gov/37634412/">최신 논문1</a></p>
<p><a href="https://pubmed.ncbi.nlm.nih.gov/34360641/">최신 논문2</a></p>
</section>
<section id="실험-내용-및-데이터" class="level2">
<h2 class="anchored" data-anchor-id="실험-내용-및-데이터">실험 내용 및 데이터</h2>
</section>
<section id="표-및-그래프-분석" class="level2">
<h2 class="anchored" data-anchor-id="표-및-그래프-분석">표 및 그래프 분석</h2>
</section>
<section id="논의-내용" class="level2">
<h2 class="anchored" data-anchor-id="논의-내용">논의 내용</h2>
</section>
<section id="단백질-연구-r-패키지" class="level2">
<h2 class="anchored" data-anchor-id="단백질-연구-r-패키지">단백질 연구 R 패키지</h2>
<ol type="1">
<li><p>단백질 데이터 분석 <a href="&quot;https://www.bioconductor.org/packages/release/data/experiment/vignettes/RforProteomics/inst/doc/RforProteomics.html&quot;">참고1</a></p></li>
<li><p>단백질 분석 자료 <a href="&quot;https://pnnl-comp-mass-spec.github.io/proteomics-data-analysis-tutorial/index.html&quot;">참고2</a></p></li>
<li><p>단백질 분석 자료 <a href="&quot;https://academic.oup.com/bioinformaticsadvances/article/2/1/vbab041/6459165&quot;">참고3</a></p></li>
<li><p>3D 단백질 그리기 패키지 <a href="&quot;http://thegrantlab.org/bio3d/&quot;">참고4</a></p></li>
</ol>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>